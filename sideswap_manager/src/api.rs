use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};
use sideswap_types::{duration_ms::DurationMs, fee_rate::FeeRateSats, timestamp_ms::TimestampMs};

#[derive(Debug, Serialize)]
pub enum ErrorCode {
    /// Something wrong with the request arguments
    InvalidRequest,
    /// Server error
    ServerError,
    /// Network error (e.g., cannot reach Electrs or SideSwap backend)
    NetworkError,
    /// Transaction send failed due to a failed UTXO check.
    /// Since the transaction did not leave the wallet, it is safe to cancel the transaction and try again.
    UtxoCheckFailed,
}

#[derive(Debug, Serialize)]
pub struct ErrorDetails {}

#[derive(Debug, Serialize)]
pub struct Error {
    /// Error message text (human-readable)
    pub text: String,
    /// Error code (machine-readable)
    pub code: ErrorCode,
    /// Optional structured error details
    pub details: Option<ErrorDetails>,
}

// Common

pub type ReqId = i64;

/// Unique integer ID (based on current timestamp in milliseconds since UNIX epoch)
pub type QuoteId = sideswap_api::mkt::QuoteId;

/// Unique string ID (random 32 bytes in hex encoding)
pub type OrderId = sideswap_api::OrderId;

/// Only selected whitelisted assets can be used here:
/// L-BTC, USDt, EURx, MEX, DePix, AMP assets and some token assets.
/// All asset balances are reported/accepted as floating point numbers using the asset precision.
pub type Ticker = sideswap_common::dealer_ticker::DealerTicker;

/// Wallet balance as float point number in the asset precision.
pub type Balances = BTreeMap<Ticker, f64>;

#[derive(Serialize)]
pub enum TxStatus {
    /// Transaction is in the mempool
    Mempool,
    /// Transaction confirmed on the blockchain
    Confirmed,
    /// Transaction not yet propagated or rejected (or not found by the Electrs server)
    NotFound,
}

#[derive(Serialize)]
pub struct MonitoredTx {
    /// Transaction ID (can be from an accepted swap or an asset send)
    pub txid: elements::Txid,
    /// Transaction status as reported by the used Electrs server
    pub status: TxStatus,
    /// Transaction description. Examples:
    /// "send 0.0001 L-BTC to vjU3KGnCKrsZkVPMTzTBo31fPrcXpqNsyoSAEvLP2apepS1JZqvN69oj4deXt3AiBuY1ZjzRCdLkb1aQ"
    /// "swap 10 USDt for 0.0001163 L-BTC to tlq1qqt8je396rxrga980wxrmvgnafld0cvxsk0df0d84pqns4lhndnqdq986krfnkg342jnqzvs7u2j9eqk6kpncyfqyq6l0zrd9m"
    /// This message is generated by the manager and the format may change.
    pub description: String,
    /// Optional user note when the transaction was created (via SendTx or AcceptQuote)
    pub user_note: Option<String>,
}

#[derive(Deserialize)]
pub struct Recipient {
    /// Recipient address. Must be confidential Liquid Bitcoin address.
    pub address: elements::Address,
    /// Asset to send (must be a whitelisted Ticker)
    pub asset: Ticker,
    /// Asset amount as a floating point number (in asset precision)
    pub amount: f64,
}

#[derive(Serialize)]
#[serde(rename_all = "snake_case")]
pub enum BroadcastStatus {
    /// Broadcast succeeded (according to the specific node/service queried).
    /// The node has accepted the transaction, but the transaction will not necessarily be added to the blockchain.
    Success {},
    /// Broadcast failed. See `error_msg` for details.
    Error {
        /// Error text as returned by the backend (or network error).
        error_msg: String,
    },
}

#[derive(Serialize)]
pub enum TxType {
    /// Incoming transaction (one or more positive balances received)
    Incoming,
    /// Outgoing transaction (one or more negative balances detected, excluding fees)
    Outgoing,
    /// Internal wallet transaction (net wallet balance change == - network fee), e.g., consolidation.
    Redeposit,
    /// One asset received and one asset sent (indicative of a swap)
    Swap,
    /// All other transactions (e.g., asset issuance, complex scripts)
    Unknown,
}

/// Wallet transaction from the Liquid Bitcoin network as reported by LWK
#[derive(Serialize)]
pub struct WalletTx {
    /// Transaction id
    pub txid: elements::Txid,
    /// The height of the block in which the transaction is included.
    /// None if the transaction is in the mempool.
    pub height: Option<u32>,
    /// Net change in the wallet balance (only whitelisted assets) in the asset precisions
    pub balance: BTreeMap<Ticker, f64>,
    /// Network fee (in L-BTC satoshis)
    pub network_fee: u64,
    /// Transaction block timestamp (block timestamp if confirmed, none is if in mempool)
    pub timestamp: Option<TimestampMs>,
    /// Transaction type determined from the balance change (heuristic)
    pub tx_type: TxType,
}

#[derive(Serialize)]
pub struct Address {
    /// Index in the address derivation path (BIP32 index)
    pub index: u32,
    /// Confidential Liquid Bitcoin address
    pub address: elements::Address,
    /// Optional user note associated when the address was generated (via `NewAddress`)
    pub user_note: Option<String>,
}

#[derive(Debug, Copy, Clone, Serialize)]
pub enum PegTxState {
    /// Peg amount is less than the minimum and will not be processed
    InsufficientAmount,
    /// The peg transaction has been detected and the server is waiting for the required confirmations
    Detected,
    /// The server is processing the transaction (e.g., waiting for peg-out tx confirmation)
    Processing,
    /// The server has made the payout (peg-in L-BTC sent or peg-out BTC sent)
    Done,
}

#[derive(Debug, Clone, Serialize)]
pub struct PegTxStatus {
    /// Txid of the user's payment (BTC for peg-in, L-BTC for peg-out).
    pub tx_hash: sideswap_api::Hash32,
    /// Output index (vout) of the user's payment.
    pub vout: u32,
    /// How much the user has paid (in bitcoins for peg-in, liquid bitcoins for peg-out)
    pub peg_amount: f64,
    /// How much will be paid or has been paid (in L-BTC for peg-ins, BTC for peg-outs).
    /// Will be empty if `tx_state` is InsufficientAmount.
    pub payout_amount: Option<f64>,
    /// Peg state
    pub tx_state: PegTxState,
    /// How many confirmations the detected transaction currently has.
    /// Set if and only if `tx_state` is `Detected`.
    pub detected_confs: Option<u32>,
    /// How many confirmations are required before processing begins.
    /// Set if and only if `tx_state` is `Detected`.
    pub total_confs: Option<u32>,
    /// Timestamp of when the peg transaction was first detected by the server
    pub created_at: TimestampMs,
    /// Payout txid (Liquid Bitcoin for peg-ins and Bitcoin for peg-outs).
    /// Set if and only if `tx_state` is `Done`.
    pub payout_txid: Option<sideswap_api::Hash32>,
}

#[derive(Debug, Clone, Serialize)]
pub struct PegStatus {
    /// Peg order id (generated by the server)
    pub order_id: OrderId,
    /// true for peg-ins (BTC -> L-BTC), false for peg-outs (L-BTC -> BTC)
    pub peg_in: bool,
    /// Server address to send funds to (Bitcoin address for peg-ins, Liquid address for peg-outs)
    pub addr_server: String,
    /// User's address to receive funds from (Liquid address for peg-ins, Bitcoin address for peg-outs). Provided by user in `NewPegReq`.
    pub addr_recv: String,
    /// List of detected user payments towards this peg order (can be more than one if user sends multiple times to `addr_server`).
    /// Will be empty for newly created peg requests until a payment is detected.
    pub list: Vec<PegTxStatus>,
    /// Timestamp of when the peg order was created via `NewPeg`
    pub created_at: TimestampMs,
    /// Optional user-submitted return address used for refunding `InsufficientAmount` peg-outs (liquid bitcoin address).
    pub return_address: Option<String>,
}

// --- Requests ---

/// NewAddress request
///
/// Generates a new unused address derived from the wallet's mnemonic.
/// The application searches for the first unused index by checking both the blockchain history and the local DB (`Address` entries).
/// It returns the address corresponding to the largest of the first unused index found in either source + 1.
/// A gap limit (typically 20) of consecutive unused addresses is enforced, starting from the last address with blockchain activity.
/// If the next address would exceed this gap limit, an error is returned.
/// On success, the newly generated address info (index, address, optional note) is stored in the local DB.
#[derive(Deserialize)]
pub struct NewAddressReq {
    /// Optional user note to store alongside the address in the DB.
    /// This note is not stored on the blockchain.
    pub user_note: Option<String>,
}

/// NewAddress response
#[derive(Serialize)]
pub struct NewAddressResp {
    /// Index in the address derivation path (e.g., m/84'/1776'/0'/0/{index} for wpkh)
    pub index: u32,
    /// Confidential Liquid Bitcoin address derived from the mnemonic.
    /// Addresses can be reused. While they can receive any asset, only whitelisted assets
    /// will be reported in balances and handled by the manager.
    pub address: elements::Address,
}

/// ListAddresses request
///
/// Load all addresses from the local DB that were previously generated via `NewAddress`.
#[derive(Deserialize)]
pub struct ListAddressesReq {}

/// ListAddresses response
#[derive(Serialize)]
pub struct ListAddressesResp {
    /// The list of addresses stored in the local DB.
    /// The list might have gaps in indices or not start at 0 if the wallet mnemonic was used elsewhere previously.
    pub addresses: Vec<Address>,
}

/// CreateTx request
///
/// Constructs a Liquid Bitcoin transaction to send whitelisted assets to the specified recipients.
/// - Only confidential recipient addresses are allowed.
/// - An error is returned if any specified amount (using `f64`) results
///   in a fractional remainder after converting to the asset's base unit (e.g., L-sats).
/// - The wallet must have sufficient UTXOs of the specified asset(s) to cover
///   the amounts and sufficient L-BTC UTXOs for the network fee.
/// - The created transaction is signed using the wallet's keys and stored temporarily in memory.
/// - It is *not* saved to disk persistently nor broadcast to the network by this request. Use `SendTx` for that.
#[derive(Deserialize)]
pub struct CreateTxReq {
    /// The list of recipients, each specifying an address, asset, and amount.
    pub recipients: Vec<Recipient>,
}

/// CreateTx response
#[derive(Serialize)]
pub struct CreateTxResp {
    /// Transaction ID (txid) of the created and signed transaction.
    /// This ID is needed for the subsequent `SendTx` request.
    pub txid: elements::Txid,
    /// Network fee (in L-sats) calculated for the created transaction.
    pub network_fee: u64,
}

/// SendTx request
/// Attempts to broadcast a previously created transaction (identified by `txid`) to the Liquid Network.
///
/// **Process:**
/// 1.  **Input Check (Local):** The manager verifies if the transaction inputs (UTXOs)
///     are still available in the local wallet state. If not, `ErrorCode::UtxoCheckFailed`
///     is returned, and the operation stops safely (transaction was not broadcast).
/// 2.  **Input Check (Server, Optional):** If `wallet_only` is `false` (default),
///     the manager asks the SideSwap server to check if the transaction inputs are known
///     and unspent according to its view of the network. If this check fails
///     (network error or server reports inputs spent), `ErrorCode::UtxoCheckFailed` is returned.
/// 3.  **DB Record:** A record for this transaction is added to the local database
///     for monitoring via `GetMonitoredTxs`, including the optional `user_note`.
///     This happens *before* broadcasting.
/// 4.  **Broadcast (Server, Optional):** If `wallet_only` is `false`, the manager requests
///     the SideSwap server to broadcast the transaction. The success/failure of this attempt
///     is reported in `res_server`. Network errors during this step are captured in `res_server`.
/// 5.  **Broadcast (Wallet/Electrs):** The manager attempts to broadcast the transaction directly
///     via the configured Electrs server. The success/failure of this attempt is reported in `res_wallet`.
///     Network errors during this step are captured in `res_wallet`.
/// 6.  **Cleanup:** Regardless of broadcast outcomes (unless an early `UtxoCheckFailed` occurred),
///     the temporary storage of *all* previously created (but not yet sent) transactions is cleared.
///     Only one transaction can be "pending send" at a time.
///
/// **Client Handling:**
/// - Call `CreateTx` then `SendTx` with the resulting `txid`.
/// - If `SendTx` returns `ErrorCode::UtxoCheckFailed`, the transaction definitely wasn't broadcast.
///   It's safe to abandon or retry (`CreateTx` again).
/// - If `SendTx` returns `ErrorCode::InvalidRequest`, the `txid` was not found (likely already sent/cleaned up or never created).
/// - If `SendTx` succeeds (returns `SendTxResp`), **check both `res_wallet` and `res_server`**:
///     - If both show `Success`, broadcast is likely successful, but confirmation is not guaranteed. Monitor via `GetMonitoredTxs`.
///     - If both show `Error`, broadcast likely failed. Monitor via `GetMonitoredTxs` (as the DB record was created).
///     - If one is `Success` and one is `Error`, broadcast status is uncertain. Monitor via `GetMonitoredTxs`.
/// - If `SendTx` fails with any other `ErrorCode` (e.g., `ServerError`, `NetworkError`), with timeout or with closed connection,
///   the transaction *might* have been broadcast before the error occurred. Monitor via `GetMonitoredTxs` because the DB record is created early.
#[derive(Deserialize)]
pub struct SendTxReq {
    /// Transaction ID returned by a previous `CreateTx` response.
    pub txid: elements::Txid,
    /// Optional user note to associate with this transaction in the monitored list.
    pub user_note: Option<String>,
    /// If true, bypass the SideSwap server for UTXO checks and broadcasting.
    /// Use only the local wallet state and Electrs server. Defaults to false.
    #[serde(default)]
    pub wallet_only: bool,
}

/// SendTx response
#[derive(Serialize)]
pub struct SendTxResp {
    /// The broadcast status reported by the connected Electrs server.
    pub res_wallet: BroadcastStatus,
    /// The broadcast status reported by the SideSwap server.
    /// This is `None` if `wallet_only` was `true` in the request.
    pub res_server: Option<BroadcastStatus>,
}

/// GetQuote request
///
/// Requests a swap quote from the SideSwap market maker backend.
/// - A market (`send_asset` <-> `recv_asset`) must exist and have available liquidity.
/// - An error is returned if no matching orders can fulfill the requested `send_amount`.
/// - Quoted amounts (`recv_amount`) include SideSwap server fees and fixed network fees.
/// - Requires an active WebSocket connection to the SideSwap server backend (managed internally).
#[derive(Deserialize)]
pub struct GetQuoteReq {
    /// The asset the user wants to sell.
    pub send_asset: Ticker,
    /// The asset the user wants to buy.
    pub recv_asset: Ticker,
    /// The exact amount of `send_asset` the user will provide.
    pub send_amount: f64,
    /// The Liquid confidential address that will receive the `recv_asset`.
    /// This address does *not* need to belong to the user's wallet.
    pub receive_address: elements::Address,
    /// If true, use only orders within a predefined price range (within 1-2% of the index price).
    /// This reduces liquidity but is safer.
    #[serde(default)]
    pub instant_swap: bool,
}

/// GetQuote response
#[derive(Serialize)]
pub struct GetQuoteResp {
    /// Quote ID, needed to accept the quote via `AcceptQuote`. Valid only for the `ttl` duration.
    pub quote_id: QuoteId,
    /// The exact amount of `recv_asset` the user will receive if the quote is accepted.
    pub recv_amount: f64,
    /// Time-To-Live: Duration (in milliseconds) for which this quote is valid and can be accepted. Typically around 30 seconds.
    pub ttl: DurationMs,
    /// Transaction ID (txid) of the atomic swap transaction prepared by the server. This txid will be monitored if the quote is accepted.
    pub txid: elements::Txid,
}

/// AcceptQuote request
///
/// Accepts a previously obtained quote (identified by `quote_id`).
///
/// **Process:**
/// 1.  **Validation:** The manager checks if the `quote_id` exists and is still within its `ttl`.
///     If not, `ErrorCode::InvalidRequest` is returned.
/// 2.  **DB Record:** A record for the swap transaction (`txid` from the original quote) is added
///     to the local database for monitoring via `GetMonitoredTxs`, including the optional `user_note`.
/// 3.  **Server Request:** The manager sends the acceptance request to the SideSwap backend.
///     The backend handles the atomic swap execution.
///
/// **Client Handling:**
/// - If the request returns `ErrorCode::InvalidRequest`,
///   the quote is likely expired or invalid. Request a new quote (`GetQuote`).
/// - If the request succeeds OR fails with any other error code,
///   the client should assume the swap *might* proceed or *might* have failed.
///   The definitive status should be checked by monitoring the transaction `txid`
///   (obtained from the original `GetQuoteResp`) using the `GetMonitoredTxs` request.
#[derive(Deserialize)]
pub struct AcceptQuoteReq {
    /// Quote ID obtained from a previous `GetQuoteResp`.
    pub quote_id: QuoteId,
    /// Optional user note to associate with this swap transaction in the monitored list.
    pub user_note: Option<String>,
}

/// AcceptQuote response
#[derive(Serialize)]
pub struct AcceptQuoteResp {
    /// Transaction ID (txid) of the swap transaction being executed.
    /// This should match the `txid` from the corresponding `GetQuoteResp`.
    pub txid: elements::Txid,
}

/// NewPeg request
///
/// Registers the user's intent to perform a peg-in (BTC -> L-BTC) or peg-out (L-BTC -> BTC) with the SideSwap server.
/// The server generates addresses for the user to send funds to.
/// - If the request fails due to network errors, it is generally safe to retry.
/// - On success, the server returns a `PegStatus` containing the details
/// (server address, order ID, etc.), and this order ID is stored locally in the DB for tracking.
/// Subsequent status updates will be delivered via `PegStatusNotif`.
#[derive(Deserialize)]
pub struct NewPegReq {
    /// The user's address that will receive the converted funds.
    /// (Liquid address for peg-ins, Bitcoin address for peg-outs).
    pub addr_recv: String,
    /// `true` for peg-in (BTC -> L-BTC), `false` for peg-out (L-BTC -> BTC).
    pub peg_in: bool,
    /// Fee rate (in sats/vbyte) used for the peg-out bitcoin transaction.
    /// If not set, the current value is used for 2 blocks.
    /// Cannot be less than 1.0.
    pub fee_rate: Option<FeeRateSats>,
}

/// NewPeg response
#[derive(Serialize)]
pub struct NewPegResp {
    /// Initial status of the newly created peg order.
    /// The `list` field (detected transactions) will be empty.
    pub peg: PegStatus,
}

/// DelPeg request
///
/// Removes a peg order (identified by `order_id`) from the local database.
/// - This stops the manager from tracking this peg order and sending `PegStatusNotif` updates for it.
/// - This request only affects the local client/manager; it does *not* cancel or delete the order on the SideSwap server.
#[derive(Deserialize)]
pub struct DelPegReq {
    /// The ID of the peg order to stop monitoring locally.
    pub order_id: OrderId,
}

/// DelPeg response
#[derive(Serialize)]
pub struct DelPegResp {}

/// GetMonitoredTxs request
///
/// Retrieves the list of all transactions currently being monitored by the manager.
/// This includes transactions initiated via `SendTx` and `AcceptQuote` that haven't been removed by `DelMonitoredTx`.
/// The status (`TxStatus`) reflects the latest information obtained from the Electrs server.
#[derive(Deserialize)]
pub struct GetMonitoredTxsReq {}

/// GetMonitoredTxs response
#[derive(Serialize)]
pub struct GetMonitoredTxsResp {
    /// The list of monitored transactions and their current status.
    pub txs: Vec<MonitoredTx>,
}

/// DelMonitoredTx request
///
/// Removes a transaction (identified by `txid`) from the local monitoring list.
/// - This stops the transaction from appearing in the `GetMonitoredTxs` response.
/// - It does *not* affect the transaction's presence in the wallet history (`GetWalletTxs`) or on the blockchain.
/// - Useful for cleaning up completed or irrelevant monitored transactions.
#[derive(Deserialize)]
pub struct DelMonitoredTxReq {
    /// The ID of the transaction to remove from monitoring.
    pub txid: elements::Txid,
}

/// DelMonitoredTx response
#[derive(Serialize)]
pub struct DelMonitoredTxResp {}

/// GetWalletTxs request
///
/// Retrieves the transaction history for the wallet,
/// as reported by the underlying LWK instance (via Electrs).
#[derive(Deserialize)]
pub struct GetWalletTxsReq {}

/// GetWalletTxs response
#[derive(Serialize)]
pub struct GetWalletTxsResp {
    /// List of wallet transactions, typically ordered from newest to oldest.
    pub txs: Vec<WalletTx>,
}

// --- Notifications ---

/// Wallet balances notification
///
/// Sent automatically when:
/// - A new client connects (providing the initial balance state).
/// - The wallet balance for any whitelisted asset changes (due to incoming/outgoing txs, swaps).
#[derive(Debug, Serialize, PartialEq, Clone)]
pub struct BalancesNotif {
    /// Current wallet balances for all whitelisted assets (UTXOs on the blockchain and in the mempool)
    pub balances: Balances,
    /// Current wallet balances for all whitelisted assets (only UTXOs on the blockchain)
    pub confirmed: Balances,
}

/// Peg status notification
///
/// Provides updates on the status of ongoing peg-in/peg-out orders stored in the local DB.
/// Sent automatically when:
/// - The connection to the SideSwap server backend is established (fetches status for all known pegs).
/// - A new client connects (sends current status for all known pegs to that client).
/// - The SideSwap server pushes a status update for a specific peg order.
/// This ensures all connected clients maintain a consistent view of peg statuses.
#[derive(Debug, Serialize, Clone)]
pub struct PegStatusNotif {
    /// The latest status of a specific peg order.
    pub peg: PegStatus,
}

// --- Top level WS messages ---

/// Request messages (Client -> Manager)
#[derive(Deserialize)]
pub enum Req {
    NewPeg(NewPegReq),
    DelPeg(DelPegReq),
    NewAddress(NewAddressReq),
    ListAddresses(ListAddressesReq),
    CreateTx(CreateTxReq),
    SendTx(SendTxReq),
    GetQuote(GetQuoteReq),
    AcceptQuote(AcceptQuoteReq),
    GetMonitoredTxs(GetMonitoredTxsReq),
    DelMonitoredTx(DelMonitoredTxReq),
    GetWalletTxs(GetWalletTxsReq),
}

/// Response messages (Manager -> Client)
#[derive(Serialize)]
pub enum Resp {
    NewPeg(NewPegResp),
    DelPeg(DelPegResp),
    NewAddress(NewAddressResp),
    ListAddresses(ListAddressesResp),
    CreateTx(CreateTxResp),
    SendTx(SendTxResp),
    GetQuote(GetQuoteResp),
    AcceptQuote(AcceptQuoteResp),
    GetMonitoredTxs(GetMonitoredTxsResp),
    DelMonitoredTx(DelMonitoredTxResp),
    GetWalletTxs(GetWalletTxsResp),
}

/// Notification messages (Manager -> Client)
#[derive(Serialize, Clone)]
pub enum Notif {
    Balances(BalancesNotif),
    PegStatus(PegStatusNotif),
}

/// Top-level message envelope sent BY clients TO the manager via WebSocket.
#[derive(Deserialize)]
pub enum To {
    /// A request that expects a response or error.
    Req {
        /// Unique request ID provided by the client to correlate responses.
        id: ReqId,
        /// The actual request payload.
        req: Req,
    },
}

/// Top-level message envelope sent TO clients FROM the manager via WebSocket.
#[derive(Serialize)]
pub enum From {
    /// Response to a specific client request.
    Resp {
        /// The ID from the original `To::Req` message.
        id: ReqId,
        /// The actual response payload.
        resp: Resp,
    },
    /// Error response to a specific client request.
    Error {
        /// The ID from the original `To::Req` message.
        id: ReqId,
        /// The error details.
        err: Error,
    },
    /// Asynchronous notification sent to clients. Not tied to a specific request ID.
    Notif {
        /// The actual notification payload.
        notif: Notif,
    },
}
